/********************************** (C) COPYRIGHT *******************************
* File Name          : Main.c
* Author             : WCH
* Version            : V1.0
* Date               : 2020/07/31
* Description 		 : CH565/569 千兆以太网链路层收发接口，使用以太网时，主频不得低于60MHz
* Copyright (c) 2021 Nanjing Qinheng Microelectronics Co., Ltd.
* SPDX-License-Identifier: Apache-2.0
*******************************************************************************/

/*-----------------------------------头文件包含--------------------------------------*/
#include "CH56x_common.h"
#include "ethernet_driver.h"
#include "ethernet_config.h"
#include "timer.h"

#ifdef USE_ETH_PHY_INTERRUPT
#include "PHY_interrupt.h"
#endif

/*-------------------------------全局变量--------------------------------------*/

/* MAC收发队列内存申请 */
__attribute__ ((aligned(16)))
__attribute__((section(".dmadata")))
UINT8 MAC_QUEUE[TxDscrOffset*TX_Des_Num+                     /* 发送描述符需要的空间 */
				RxDscrOffset*RX_Des_Num+                     /* 接收描述符需要的空间 */
				TX_Des_Num*TX_Buf_Size+                      /* 发送缓冲区需要的空间 */
				RX_Des_Num*RX_Buf_Size];                     /* 接收缓冲区需要的空间 */

ETH_DMADESCTypeDef  *DMATxDescToSet;                        /* 当前发送描述符指针 */
ETH_DMADESCTypeDef  *DMARxDescToGet;                        /* 当前接收描述符指针 */

extern Globe_RxDes_status_t Globe_RxDes_status;
UINT8 local_mac[6]={0x84,0xc2,0xe4,0x01,0x02,0x03,};
volatile UINT8 enable_send;
volatile UINT8 rece_timeout_cnt;    /* 接收超时计时器 */
UINT32 TIMEOUT_CNT=0;               /* 接收超时计次器 */


/*******************************************************************************
 * @fn      DebugInit
 *
 * @brief   Initializes the UART1 peripheral.
 *
 * @param   baudrate: UART1 communication baud rate.
 *
 * @return  None
 */
void DebugInit(UINT32 baudrate)
{
	UINT32 x;
	UINT32 t = FREQ_SYS;
	
	x = 10 * t * 2 / 16 / baudrate;
	x = ( x + 5 ) / 10;
	R8_UART1_DIV = 1;
	R16_UART1_DL = x;
	R8_UART1_FCR = RB_FCR_FIFO_TRIG | RB_FCR_TX_FIFO_CLR | RB_FCR_RX_FIFO_CLR | RB_FCR_FIFO_EN;
	R8_UART1_LCR = RB_LCR_WORD_SZ;
	R8_UART1_IER = RB_IER_TXD_EN;
	R32_PA_SMT |= (1<<8) |(1<<7);
	R32_PA_DIR |= (1<<8);
}

#if 1
UINT8 ARP_package[]=
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff,/* 目标MAC */
	0x84, 0xc2, 0xe4, 0x01, 0x02, 0x03,/* 源MAC */
	0x08,0x06,/* ARP包 */
	0x00,0x01,/* 硬件类型 */
	0x08,0x00,/* 协议类型 */
	0x06,0x04,/* 硬件地址长度和协议地址长度 */
	0x00,0x01,/* 情求包 */
	0x84, 0xc2, 0xe4, 0x01, 0x02, 0x03,/* 源MAC地址 */
	0xc0,0xa8,0x1,0x0f,/* 源协议地址 */
	0x00,0x00,0x00,0x00,0x00,0x00,/* 目标MAC地址 */
	0xc0,0xa8,0x1,0x0a,/* 源协议地址 */
#if 1 /*padding 16bytes*行数   */
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
	0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
#endif
};
#endif

#define  target_msg_ptr ARP_package /* 定义测试发送的数据 */

/*********************************************************************
 * @fn      main
 *
 * @brief   Main program.
 *
 * @return  none
 */
int main()
{  
	UINT8 rc,i;/* 状态 */
	UINT8 *read_ptr,**p=&read_ptr;
	UINT16 read_length;
	UINT32 DIFF=0;

    /* 系统初始化 */
    SystemInit(FREQ_SYS);
    Delay_Init(FREQ_SYS);

    /* 配置串口调试 */
	DebugInit(921600);
	PRINT("Start @ChipID=%02X\r\n", R8_CHIP_ID );
	PRINT("WCH Gigabits Ethernet MAC driver program demo! \n");
	PRINT("System frequence is :%d Hz,Complair at  %s,%s\n",FREQ_SYS,__DATE__,__TIME__);

	/* MAC初始化，需要保证网线/光纤已经插上 */
	ETH_init();

//	TMR0_init(FREQ_SYS/1000);/* 定时器初始化,用于在收发逻辑中超时的情况下恢复发送 */

	/* 配置发送时钟延迟，在接收侧，RGMII的时钟需要比数据延迟1/4周期。用户需要根据自己的PCB情况保证 */
#ifdef USE_RTL8211FS
	RGMII_TXC_Delay(0,2);/* RGMII发送延迟和相位调整 */
#endif
#ifdef USE_RTL8211DN
	RGMII_TXC_Delay(0,3);/* RGMII发送延迟和相位调整 */
#endif
	Check_TxDes();/* 发送描述符检查 */
#ifdef USE_ETH_PHY_INTERRUPT
	phy_int_cheak_init();
#endif
	/* 预先填好两个发送缓冲区，节省复制时间 */
	memcpy(pTx_Buff,target_msg_ptr,sizeof(target_msg_ptr));
	memcpy((UINT8*)(pTx_Buff+RX_Buf_Size),target_msg_ptr,sizeof(target_msg_ptr));
	enable_send=1;/* 使能发送 */
	printf("enter main loop!\n");

    while(1)
    {
#if 1/* 接收 */
		mDelayuS(1);/* 避免编译器省去下面的变量 */
		if(Globe_RxDes_status.pengding_RxDes_cnt)
		{
			read_length=mac_rece(p);
//			if(ETH->MMCRGUFCR%100000==0)
//			{
//				PRINT("T:%d.R:%d.\n",ETH->MMCTGFCR,ETH->MMCRGUFCR);
//				printf("C:%d,+:%d.\n",ETH->MMCRFCECR,ETH->MMCRFCECR-DIFF);
//				DIFF=ETH->MMCRFCECR;
//			}
//			printf("0x%08x：0x%08x\n",&(DMARxDescToGet->Status),DMARxDescToGet->Status);
//			printf("0x%08x：0x%08x\n",&(DMARxDescToGet->ControlBufferSize),DMARxDescToGet->ControlBufferSize);
//			printf("0x%08x：0x%08x\n",&(DMARxDescToGet->Buffer1Addr),DMARxDescToGet->Buffer1Addr);
//			printf("0x%08x：0x%08x\n",&(DMARxDescToGet->Buffer2NextDescAddr),DMARxDescToGet->Buffer2NextDescAddr);
			/* 数据在read_ptr指向的区域中，长度为read_length */
			printf("read_length:%d\n",read_length);
			PRINT("rece@0x%08x\n",read_ptr);
			for(i=0;i<6;i++)
				PRINT("%02x ",read_ptr[i]);
				printf("\n");
			for(i=6;i<12;i++)
				PRINT("%02x ",read_ptr[i]);
				printf("\n");
			for(i=12;i<22;i++)
				PRINT("%02x ",read_ptr[i]);
			PRINT("END!\n\n");
		}
#endif

#if 1/* 发送 */
		if(enable_send==0x03)
		{
//			memcpy(get_txbuff_addr(),target_msg_ptr,sizeof(target_msg_ptr));
			mac_send(sizeof(target_msg_ptr));
			enable_send=0;
//			printf("main:DMATxDescToSet:0x%08x\n",DMATxDescToSet);
//			printf("main:0x%08x:0x%08x\n",&(DMATxDescToSet->Status),DMATxDescToSet->Status);
//			printf("main:0x%08x:0x%08x\n",&(DMATxDescToSet->ControlBufferSize),DMATxDescToSet->ControlBufferSize);
//			printf("main:0x%08x:0x%08x\n",&(DMATxDescToSet->Buffer1Addr),DMATxDescToSet->Buffer1Addr);
//			printf("main:0x%08x:0x%08x\n",&(DMATxDescToSet->Buffer2NextDescAddr),DMATxDescToSet->Buffer2NextDescAddr);
//			if(ETH->MMCTGFCR%1000==0)
//			{
//				printf("RGUFCR:%d.\n",ETH->MMCRGUFCR);
//				printf("RFCECR:%d.\n",ETH->MMCRFCECR);
//				PRINT("CNT overflow.T:%d.R:%d.\n",ETH->MMCTGFCR,ETH->MMCRGUFCR);
//			}
			printf("MMCTGFCR:%d.\n",ETH->MMCTGFCR);
		}
#endif
    }
}





